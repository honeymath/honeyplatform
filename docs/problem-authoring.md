# Problem Authoring Guide

## Overview

Every Honeymath problem is a standalone Python script. The platform simply runs the script and handles I/O through the browser. This means your problems:

- Run in terminal (`python3 problem.py`)
- Run in Jupyter notebooks
- Run in the Honeymath browser platform
- Can be generated by ChatGPT
- Are version-controllable via Git

## The Three Primitives

Your problem script communicates with the platform using three Python constructs:

### 1. `print(message)` - Display Content

Displays text to the student. Supports LaTeX math notation.

```python
print("What is $1 + 1$?")
print(rf"Find the eigenvalues of $$A = {latex(A)}$$")
```

**LaTeX rules:**
- Inline math: `$...$`
- Display math: `$$...$$`
- Use `rf"..."` (raw f-string) to avoid escaping backslashes in LaTeX commands
- Always wrap sympy expressions with `latex()`: `{latex(A)}` not `{A}`

### 2. `input()` - Collect Student Answer

Pauses execution and waits for the student to provide an answer.

```python
# Simple text/number input (shows a text area)
answer = input()

# Matrix input (shows visual matrix editor)
X = json.loads(input())  #matrixlist
```

**Input types** are determined by a comment tag on the `input()` line:

| Code | UI Component | Returns |
|------|-------------|---------|
| `input()` | Text area (default) | String |
| `input() #textarea` | Text area (explicit) | String |
| `input() #checkbox` | Checkbox selection | String (`"true"` or `"false"`) |
| `input() #radio` | Radio button selection | String (selected option) |
| `input() #matrixlist` | Matrix editor (DEPRECATED — see [ADR-0002](../docs/adr/0002-matrixinput-deprecation.md)) | JSON string of 3D array `[[[row1], [row2]], ...]` |

**Important:** `input()` always returns a **string**. You must parse it yourself:
```python
n = int(input())              # number
X = json.loads(input())       # matrixlist → 3D Python array
answer = input().strip()      # text with whitespace trimmed
```

### 3. `raise Exception(message)` - Wrong Answer Feedback

Indicates the student's answer is incorrect. The message is shown in red.

```python
if answer != "2":
    raise Exception(f"Incorrect. The answer is not {answer}.")
```

If the program completes without raising any Exception, the answer is considered **correct** and "Accepted" is shown in green.

## Partial Credit

Append `#score = X` to the `raise Exception` line to give partial credit:

```python
if P != A:
    raise Exception(rf"$UU^T \neq A$")  #score = 0.5
```

The score must be a number between 0 and 1. If no `#score` comment is present, the score defaults to 0 for that problem.

## Input Tag Protocol

Input types and parameters are specified via comment tags on the `input()` line using `#<name>` or `#<name>=<value>` syntax.

### Syntax Rules

1. Tags appear as Python comments on the `input()` line
2. Simple tags: `#tagname` — selects an input type
3. Key-value tags: `#key=value` — sets a parameter
4. **Locality rule**: Tags only apply to the `input()` call on the same line. They do not carry over to subsequent `input()` calls.

### Supported Tags

| Tag | Description |
|-----|-------------|
| `#textarea` | Multi-line text input (this is the default if no tag is specified) |
| `#checkbox` | Checkbox selection |
| `#radio` | Radio button selection |
| `#matrixlist` | Matrix editor (DEPRECATED — see [ADR-0002](../docs/adr/0002-matrixinput-deprecation.md)) |
| `#rows=N` | Number of rows for textarea |
| `#score=X` | Partial credit (used on `raise Exception` lines) |

### Examples

```python
# Default text input (no tag needed)
answer = input()

# Explicit textarea
answer = input()  #textarea

# Checkbox
yn = input()  #checkbox

# Radio selection
choice = input()  #radio
```

### Standalone Compatibility

When running as `python3 problem.py`, tags are just comments and are ignored by Python. `input()` falls through to standard stdin.

### Migration from `#matrixlist`

`#matrixlist` is deprecated. For new problems, use `#textarea` and instruct students on the expected format:

```python
# Old (deprecated):
X = json.loads(input())  #matrixlist

# New:
print("Enter matrix rows, one per line (e.g., '1 2 3'):")
answer = input()  #textarea
```

See [ADR-0002](../docs/adr/0002-matrixinput-deprecation.md) and [ADR-0003](../docs/adr/0003-input-tag-protocol.md) for design rationale.

## Multi-Part Questions

A single problem can have multiple `input()` calls. Each one creates a separate sub-question. Later parts can use answers from earlier parts:

```python
from sympy import Matrix, latex
import json

A = Matrix([[2, 1], [1, 3]])
print(rf"Given $$A = {latex(A)}$$")

# Part 1: eigenvalue
print("Find one eigenvalue of $A$.")
eigenvalue = int(input())
print(f"You said the eigenvalue is ${eigenvalue}$.")

if eigenvalue not in [e for e in A.eigenvals()]:
    raise Exception(f"${eigenvalue}$ is not an eigenvalue of $A$.")  #score = 0.3

# Part 2: eigenvector (depends on Part 1)
print(rf"Find an eigenvector for $\lambda = {eigenvalue}$.")
X = json.loads(input())  #matrixlist
v = Matrix(X[0])
print(rf"You entered $$v = {latex(v)}$$")

if A * v != eigenvalue * v:
    raise Exception(rf"$Av \neq {eigenvalue}v$")  #score = 0.6
```

## Random Seed

The platform calls `random.seed(student_id)` and `numpy.random.seed(student_id)` before running each problem. This means:

- Same student ID always generates the same problem
- Different students get different random numbers
- You do **not** need to call `random.seed()` yourself

```python
import random
from sympy import Matrix, latex

# This generates different values for each student
n = random.randint(2, 5)
A = Matrix([[random.randint(-3, 3) for _ in range(n)] for _ in range(n)])

print(rf"Compute $\det(A)$ where $$A = {latex(A)}$$")
det = int(input())
if det != A.det():
    raise Exception(rf"Incorrect. $\det(A) \neq {det}$")
```

### Per-Package Seed Behavior

The platform seeds three random sources before each problem execution:

| Package | Seed Method | Isolation | Order-Dependent? |
|---------|-------------|-----------|------------------|
| `random` | `random.seed(student_id)` | Global state | Yes — each call to `random.randint()` etc. advances the global state |
| `numpy.random` | `numpy.random.seed(student_id)` | Global state | Yes — each call to `numpy.random.*` advances the global state |
| `sympy.randMatrix` | Patched to use `random.Random(student_id)` | **Isolated instance** | No — uses its own private PRNG, does not affect `random` or `numpy` state |

### Important Rules

1. **`random` and `numpy.random` are order-dependent**: The sequence of random calls determines the output. Adding a `random.randint()` call before existing ones will change all subsequent values.

2. **`sympy.randMatrix` is isolated**: It uses a separate `random.Random(student_id)` instance, so calling it does not affect the state of `random` or `numpy.random`.

3. **Don't mix `random` and `numpy.random`**: They have separate global states. If you mix them, the reproducibility becomes harder to reason about. Pick one source per problem.

4. **If you need order-independent randomness**, create your own `random.Random(seed)` instance:
   ```python
   rng = random.Random(42)  # private instance, won't affect global state
   n = rng.randint(2, 5)
   ```

### Local Testing

To test that your problem generates consistent output for a given seed:

```bash
python3 -c "
import random, numpy
random.seed(12345)
numpy.random.seed(12345)
exec(open('your_problem.py').read())
"
```

Run this twice — the output should be identical.

See [ADR-0004](../docs/adr/0004-random-seed-stabilization.md) for the full design rationale.

## Best Practices

### Always Echo Student Input

Always display what you received from the student. This helps debug mismatches between what the student intended and what the platform captured:

```python
X = json.loads(input())  #matrixlist
M = Matrix(X[0])
print(rf"You entered $$M = {latex(M)}$$")  # Always echo!
```

### Generate Integer-Friendly Problems

Students shouldn't need calculators. Use matrix construction techniques that guarantee integer solutions:

**Integer invertible matrix (det = 1) via PLU decomposition:**
```python
import random
from sympy import Matrix, eye

n = 3
scale = 3

# Upper triangular with 1s on diagonal
upper = [[1 if i == j else (random.randint(-scale, scale) if j > i else 0)
          for j in range(n)] for i in range(n)]

# Lower triangular with 1s on diagonal
lower = [[1 if i == j else (random.randint(-scale, scale) if i > j else 0)
          for j in range(n)] for i in range(n)]

# Random permutation
perm = list(range(n))
random.shuffle(perm)
P = eye(n)[perm, :]

# Product has det = +-1, so inverse is also integer
A = P * Matrix(upper) * Matrix(lower)
```

**Integer eigenvalue problems:**
Use $A = P \Lambda P^{-1}$ where $P$ is an integer matrix with $\det(P) = 1$ and $\Lambda$ is diagonal with integer entries:

```python
eigenvalues = [random.randint(1, 5) for _ in range(n)]
Lambda = Matrix.diag(*eigenvalues)
# P from the PLU construction above (det = 1)
A = P * Lambda * P.inv()
# A now has integer entries and integer eigenvalues
```

### Validate Input Format Before Checking Correctness

```python
import re

answer = input().strip().upper()
answer = re.sub(r'[^a-zA-Z0-9]', '', answer)

if answer not in ['YES', 'NO']:
    raise Exception("Please answer Yes or No.")

# Now check correctness...
```

### Use Descriptive Error Messages

```python
# Bad
raise Exception("Wrong")

# Good
raise Exception(rf"$Av = {latex(A * v)}$, but $\lambda v = {latex(eigenvalue * v)}$. These are not equal.")
```

## Available Python Packages

The browser runtime (Pyodide) pre-loads:

| Package | Common Imports |
|---------|---------------|
| **sympy** | `Matrix, symbols, Eq, latex, sqrt, Rational, eye, zeros, ones, randMatrix, det, solve` |
| **numpy** | `numpy as np`, `numpy.linalg` |
| **random** | `random.randint, random.shuffle, random.seed, random.Random` |
| **json** | `json.loads, json.dumps` |
| **re** | `re.sub, re.match` |

Standard library modules (`math`, `itertools`, `functools`, etc.) are also available.

## Complete Example

```python
from sympy import Matrix, latex, eye, randMatrix
import json
import random

# --- Problem Setup ---
n = 3
# Construct an integer matrix with known PLU decomposition
L = Matrix([[1, 0, 0],
            [random.randint(-2, 2), 1, 0],
            [random.randint(-2, 2), random.randint(-2, 2), 1]])
U = Matrix([[1, random.randint(-2, 2), random.randint(-2, 2)],
            [0, 1, random.randint(-2, 2)],
            [0, 0, 1]])
A = L * U

print(rf"""
Perform LU decomposition on the following matrix:
$$A = {latex(A)}$$
Find a lower triangular matrix $L$ and an upper triangular matrix $U$
such that $A = LU$.
""")

# --- Part 1: L matrix ---
print("Enter the lower triangular matrix $L$:")
X = json.loads(input())  #matrixlist
L_student = Matrix(X[0])
print(rf"You entered $$L = {latex(L_student)}$$")

if not L_student.is_lower:
    raise Exception("Your matrix is not lower triangular.")  #score = 0.1

# --- Part 2: U matrix ---
print("Enter the upper triangular matrix $U$:")
Y = json.loads(input())  #matrixlist
U_student = Matrix(Y[0])
print(rf"You entered $$U = {latex(U_student)}$$")

if not U_student.is_upper:
    raise Exception("Your matrix is not upper triangular.")  #score = 0.3

# --- Verification ---
product = L_student * U_student
print(rf"$$LU = {latex(product)}$$")

if product != A:
    raise Exception(rf"$LU \neq A$. Check your decomposition.")  #score = 0.5

print("Correct! Your LU decomposition is valid.")
```
